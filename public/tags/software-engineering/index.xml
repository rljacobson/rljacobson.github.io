<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on After Math</title>
    <link>http://localhost:1313/tags/software-engineering/</link>
    <description>Recent content in Software Engineering on After Math</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Robert Jacobson</copyright>
    <lastBuildDate>Mon, 02 Dec 2024 21:18:14 -0600</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Common Optimizations for Levenshtein Edit Distance</title>
      <link>http://localhost:1313/posts/2024-12-02-edit-distance-optimizations/</link>
      <pubDate>Mon, 02 Dec 2024 21:18:14 -0600</pubDate>
      <guid>http://localhost:1313/posts/2024-12-02-edit-distance-optimizations/</guid>
      <description>I have been studying algorithms to compute the Levenshtein edit distance between two strings, which is defined as the minimum number of &amp;ldquo;edits&amp;rdquo; required to transform one string into another string. This is useful for a variety of things, from DNA sequence alignment to spell correction to address validation. I am studying it to resolve misspelled and OCR&amp;rsquo;ed scientific names of organisms to their real names, a famous problem in the field.</description>
    </item>
    <item>
      <title>Making a Pratt Parser Generator Part 2</title>
      <link>http://localhost:1313/posts/2024-02-24-making-a-pratt-parser-generator-part-2/</link>
      <pubDate>Sat, 24 Feb 2024 11:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/2024-02-24-making-a-pratt-parser-generator-part-2/</guid>
      <description>Recap In Part 1 I made the case against the standard object-oriented design for Pratt parsers in favor of a design in which generic algorithms are driven by a database of operator data read in at run time. I described the alternative design in broad strokes. In this article, I will dig into some actual code and highlight particular differences from the standard object oriented design along the way.&#xA;Operator Database Our language is a toy mathematical expression language.</description>
    </item>
    <item>
      <title>Making a Pratt Parser Generator Part 1</title>
      <link>http://localhost:1313/posts/2020-08-13-designing-a-pratt-parser-generator/</link>
      <pubDate>Thu, 13 Aug 2020 11:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/2020-08-13-designing-a-pratt-parser-generator/</guid>
      <description>A brief history of the Pratt parsing algorithm The history of programming language parsers is dominated by the thorny challenge of parsing expressions, mathematical expressions in particular, taking into account the precedence of operators in the expressions. Modern formal language theory began with the work of Noam Chomsky in the 1950s, in which Chomsky lays out a mathematical framework for linguistics. Under this mathematical framework, languages exist within a hierarchy of languages defined according to how difficult the language is to parse.</description>
    </item>
  </channel>
</rss>
